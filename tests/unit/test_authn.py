#!/usr/bin/env python3
"""
Authentication Unit Tests

Tests for the authentication system including token generation, validation,
and various failure scenarios using the validate_token method.
"""

import pytest
import jwt
from datetime import datetime, timezone, timedelta
from multi_eden.run.auth.testing import get_static_test_user_token
from multi_eden.run.auth.util import gen_token, gen_token_using_dates
from multi_eden.run.auth.validator import validate_token
from multi_eden.run.auth.exceptions import AuthenticationError, TokenExpiredError, TokenSignatureError, TokenMalformedError, TokenIssuerError
from multi_eden.run.config import get_setting


class TestAuthentication:
    """Test class for authentication functionality."""
    
    def setup_method(self, method):
        """Set up for each test method."""
        import logging
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def test_generated_tokens_have_correct_structure(self):
        """Test that generated tokens have correct structure and format."""
        self.logger.info("🔑 TESTING GENERATED TOKENS HAVE CORRECT STRUCTURE:")
        
        # Generate a token using gen_token utility
        email = "test-user@example.com"
        token = gen_token(email)
        
        # Decode the JWT token to examine its contents
        decoded = jwt.decode(token, options={"verify_signature": False})
        
        # Verify JWT payload fields
        assert 'iss' in decoded, "JWT should have 'iss' (issuer) field"
        assert 'sub' in decoded, "JWT should have 'sub' (subject) field"
        assert 'email' in decoded, "JWT should have 'email' field"
        assert 'uid' in decoded, "JWT should have 'uid' field"
        assert 'name' in decoded, "JWT should have 'name' field"
        assert 'iat' in decoded, "JWT should have 'iat' (issued at) field"
        assert 'exp' in decoded, "JWT should have 'exp' (expiration) field"
        
        # Verify the token is not expired
        current_time = datetime.now(timezone.utc).timestamp()
        assert decoded['exp'] > current_time, "Token should not be expired"
        
        # Verify issuer matches expected pattern
        assert 'multi-eden' in decoded['iss'], "Issuer should contain 'multi-eden'"
        
        self.logger.info("   ✅ Generated tokens have correct structure and format")
    
    def test_generated_tokens_have_valid_signatures(self):
        """Test that tokens generated by gen_token have cryptographically valid signatures."""
        self.logger.info("🔐 TESTING GENERATED TOKENS HAVE VALID SIGNATURES:")
        
        # Create a valid token
        email = "valid-user@example.com"
        valid_token = gen_token(email)
        
        # Get the JWT key for signature verification
        jwt_key = get_setting('jwt-secret-key')
        
        # Verify the token signature is valid
        try:
            decoded = jwt.decode(valid_token, jwt_key, algorithms=["HS256"])
            assert decoded['email'] == email, "Decoded token should match original email"
            self.logger.info("   ✅ Token signature validation successful")
        except jwt.InvalidSignatureError:
            pytest.fail("Valid token should have valid signature")
    
    def test_token_validation_success(self):
        """Test successful validation using the validate_token function."""
        self.logger.info("✅ TESTING TOKEN VALIDATION SUCCESS:")
        
        # Create a valid token
        email = "valid-user@example.com"
        valid_token = gen_token(email)
        
        # Use the central validate_token function that the app uses
        try:
            claims = validate_token(valid_token)
            
            # Verify the returned claims
            assert claims['email'] == email, "Validated token should contain correct email"
            assert 'iss' in claims, "Validated token should contain issuer"
            assert 'sub' in claims, "Validated token should contain subject"
            assert 'iat' in claims, "Validated token should contain issued at time"
            assert 'exp' in claims, "Validated token should contain expiration time"
            
            self.logger.info("   ✅ validate_token function successfully validated token")
            
        except AuthenticationError as e:
            pytest.fail(f"Valid token should be validated successfully: {e}")
    
    def test_validate_token_function_rejects_expired(self):
        """Test that validate_token function rejects expired tokens."""
        self.logger.info("⏰ TESTING VALIDATE_TOKEN FUNCTION EXPIRED TOKEN REJECTION:")
        
        # Create an expired token (issued 2 hours ago, expired 1 hour ago)
        expired_token = gen_token_using_dates(
            email='test-user@example.com',
            issuer='https://auth.multi-eden-default.app',
            issued_at=datetime.now(timezone.utc) - timedelta(hours=2),
            expiration_datetime=datetime.now(timezone.utc) - timedelta(hours=1)
        )
        
        # Use validate_token function - should reject expired token with specific exception
        with pytest.raises(TokenExpiredError, match="Token has expired"):
            validate_token(expired_token)
        
        self.logger.info("   ✅ validate_token function properly rejected expired token")
    
    def test_validate_token_function_rejects_invalid_signature(self):
        """Test that validate_token function rejects tokens with invalid signatures."""
        self.logger.info("🔒 TESTING VALIDATE_TOKEN FUNCTION INVALID SIGNATURE REJECTION:")
        
        # Create a valid token
        valid_token = gen_token('test-user@example.com')
        
        # Decode to get the payload
        decoded_payload = jwt.decode(valid_token, options={"verify_signature": False})
        
        # Re-encode with wrong salt to create invalid signature
        wrong_salt = "wrong-salt-for-signing"
        invalid_signature_token = jwt.encode(decoded_payload, wrong_salt, algorithm="HS256")
        
        # Use validate_token function - should reject invalid signature with specific exception
        with pytest.raises(TokenSignatureError, match="Token has invalid signature"):
            validate_token(invalid_signature_token)
        
        self.logger.info("   ✅ Invalid signature token properly rejected with TokenSignatureError")
    
    def test_validate_token_function_rejects_malformed(self):
        """Test that validate_token function rejects malformed tokens."""
        self.logger.info("❌ TESTING VALIDATE_TOKEN FUNCTION MALFORMED TOKEN REJECTION:")
        
        # Test various malformed token scenarios
        malformed_tokens = [
            "not.a.jwt.token",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid_payload",
            "",  # Empty token
        ]
        
        for malformed_token in malformed_tokens:
            with pytest.raises(TokenMalformedError, match="Token is malformed"):
                validate_token(malformed_token)
        
        self.logger.info("   ✅ validate_token function properly rejected malformed tokens")
    
    def test_unknown_issuer_rejection(self):
        """Test that tokens with unknown issuers are rejected."""
        self.logger.info("🚫 TESTING UNKNOWN ISSUER REJECTION:")
        
        # Create a token with unknown issuer
        unknown_issuer_token = gen_token(
            email='test-user@example.com',
            issuer='https://unknown-issuer.com/fake-service'
        )
        
        # Verify the token has the unknown issuer
        decoded = jwt.decode(unknown_issuer_token, options={"verify_signature": False})
        assert 'https://unknown-issuer.com/fake-service' in decoded['iss']
        
        # This test documents that the system should reject unknown issuers
        # The actual rejection would happen in the authorization layer
        self.logger.info("   ✅ Unknown issuer token identified")
    
    def test_token_expiration_time_validation(self):
        """Test that token expiration times are reasonable."""
        self.logger.info("⏱️ TESTING TOKEN EXPIRATION TIME VALIDATION:")
        
        # Generate a token with default expiration
        token = gen_token('test-user@example.com')
        decoded = jwt.decode(token, options={"verify_signature": False})
        
        # Get current time
        current_time = datetime.now(timezone.utc).timestamp()
        
        # Verify token was issued recently (within last minute)
        assert decoded['iat'] >= current_time - 60, "Token should be issued recently"
        
        # Verify token expires in reasonable time (not too short, not too long)
        time_until_expiry = decoded['exp'] - current_time
        assert 3600 <= time_until_expiry <= 86400, "Token should expire in 1-24 hours"
        
        self.logger.info("   ✅ Token expiration times are reasonable")
    
    def test_token_payload_integrity(self):
        """Test that token payload contains all required fields with correct types."""
        self.logger.info("📋 TESTING TOKEN PAYLOAD INTEGRITY:")
        
        # Generate a token
        email = "test-user@example.com"
        token = gen_token(email)
        decoded = jwt.decode(token, options={"verify_signature": False})
        
        # Verify required fields exist and have correct types
        required_fields = {
            'iss': str,      # Issuer
            'sub': str,      # Subject
            'email': str,    # Email
            'uid': str,      # User ID
            'name': str,     # Name
            'iat': (int, float),  # Issued at
            'exp': (int, float),  # Expiration
        }
        
        for field, expected_type in required_fields.items():
            assert field in decoded, f"Token should contain '{field}' field"
            assert isinstance(decoded[field], expected_type), f"'{field}' should be {expected_type}"
        
        # Verify specific values
        assert decoded['email'] == email, "Email should match input"
        assert decoded['sub'] == email, "Subject should match email"
        assert decoded['uid'] == email, "User ID should match email"
        
        self.logger.info("   ✅ Token payload integrity verified")
